4 claves para dominar un idioma

1- condiciones
2- tipo de datos: es un valor en Python
3- acciones
4- las mejores practicas

los signos para matematicas en python

print(suma +)
print(resta -)
print(multiplicacion *)
print(divicion / )

incluir la palabra type ayuda a descubrir el tipo de numero, si es entero dira Int y si es decimal dira Float ejemplo:

print(type(2+4))       int
print(type(2/4))       Float

Se pueden hacer doble multiplicaion y doble divicion, como resultado dan numeros enteros redondeandolos si son decimales. ejemplos:

print(2**3)      8
print(5//4)      1




tipos fundamentales de datos


int: representara todos los numeros

str: representara todas las letras 


1 integer-Int: entero, Convierte un número o una cadena en un número entero, o devuelva 0 si no hay argumentos dados. Si x es un número, devuelve x.__int__(). Para punto flotante números, esto se trunca hacia cero.

2 float(floating): es un numero de punto flotante Convierta una cadena o un número en un número de punto flotante, si es posible.

3 bool: objeto, Devuelve True cuando el argumento x es verdadero, False en caso contrario. Los componentes True y False son las únicas dos instancias de la clase bool.
La clase bool es una subclase de la clase int y no puede subclasificarse.

4 str: Cree un nuevo objeto de cadena a partir del objeto dado. Si codifica o se especifican errores, entonces el objeto debe exponer un búfer de datos
que se decodificará utilizando la codificación y el controlador de errores proporcionados.
De lo contrario, devuelve el resultado de object.__str__() (si está definido)
o repr(objeto).
la codificación predeterminada es sys.getdefaultencoding().
errores por defecto es 'estricto'.

5 list: Secuencia mutable incorporada. Si no se proporciona ningún argumento, el constructor crea una nueva lista vacía.
El argumento debe ser iterable si se especifica.


6 tuple: Secuencia inmutable incorporada. Si no se proporciona ningún argumento, el constructor devuelve una tupla vacía.
Si se especifica iterable, la tupla se inicializa a partir de los elementos de iterable.
Si el argumento es una tupla, el valor devuelto es el mismo objeto.


7 set: Cree una colección desordenada de elementos únicos.


8 dict: objeto- dict() -> nuevo diccionario vacío
dict (mapeo) -> nuevo diccionario inicializado desde un objeto de mapeo
    (clave, valor) pares
dict (iterable) -> nuevo diccionario inicializado como si fuera a través de:
    re = {}
    para k, v en iterable:
        d[k] = v
dict(**kwargs) -> nuevo diccionario inicializado con los pares nombre=valor
    en la lista de argumentos de palabras clave. Por ejemplo: dict(uno=1, dos=2)



ejemplos:

integer: int(x: Unión[Texto, bytes, SupportsInt, _SupportsIndex]=...) int(x: Unión[Texto, bytes, bytearray], base: int)

float: float(x: Unión[SupportsFloat, _SupportsIndex, Text, bytes, bytearray]=...)

bool: bool(x) -> bool

STR: str(o: objeto=...) str(o: bytes, codificación: str=..., errores: str=...) str(objeto='') -> str
str(bytes_or_buffer[, codificación[, errores]]) -> str

list: lista() lista(iterable: Iterable[_T])

tuple: tuple(iterable: Iterable[_T_co]=...)

set: set(iterable: Iterable[_T]=...) set () -> nuevo objeto de conjunto vacío set (iterable) -> nuevo objeto de conjunto

dict: dict(**kwargs: _VT) dict(mapa: Asignación[_KT, _VT], **kwargs: _VT) dict(iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT)




PRIMERA PRUEBA PRACTICA: cada parentesis o signo es importante.

print((5 + 4) * 10 / 2)

print(((5 + 4) * 10) / 2)

print((5 + 4) * (10 / 2))

print(5 + (4 * 10) / 2)

print(5 + 4 * 10 // 2)


COMPLEX casi no se usa

Los numeros se guardan en la memoria como numeros binarios ejemplo: el numero 5 ocupa 5 espacios aunque sea 101 en binario.

Comando correcto averiguar un numero normal en binario:   print(bin(6))   respuesta: 0b110   el numero 6 en binario es: 110




